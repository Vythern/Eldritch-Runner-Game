using Unity.VisualScripting.Antlr3.Runtime.Tree;
using Unity.VisualScripting;
using UnityEngine;

public class Cell : MonoBehaviour
{
    [Header("Tiles")]
    [SerializeField] public GameObject[] floorTiles;
    [SerializeField] public GameObject[] ceilingTiles;

    private float generationBudget = 0f;
    public GameObject leftCell = null;
    public GameObject rightCell = null;

    private float gridOffset = 2.5f;

    public enum TrapType
    {
        LeftSpikes,
        RightSpikes,
        DownSpikes,
        UpSpikes,
        Lava,
        Turret,
        SwingingBall,
        SawbladeUp,
        SawbladeDown,
        SawbladeLeft,
        SawbladeRight,
        SawbladeUpLeft,
        SawbladeUpRight,
        SawbladeDownLeft,
        SawbladeDownRight
    }


    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        //since cells are generated by the game manager, we do not worry about the start method, and instead rely on the public initializeCell method to be called by the game manager.  
    }

    public void destroyCell()
    {
        if(rightCell != null) 
        {
            this.rightCell.gameObject.GetComponent<Cell>().leftCell = null; //set the left cell of the destroyed cell to null.  
        }
        GameObject.Destroy(this.gameObject);
    }

    private void randomizeCellPositions()
    {
        //the floor can always move to minimum height, and the ceiling can always move to maximum height.  
        //the floor can move up to the ceiling height of the left tile - 5
        //the ceiling can move up to the floor height of the left tile + 5
        //if we are evaluating i = 0, it means the left tile is the final tile of the leftCell
        //if we are evaluating the final iteration, it means the right tile is the first tile of the right cell.  This shouldn't matter though.  
        //floor height choice must precede ceiling height choice

        //Check if the floor and ceiling tiles can move based on these rules
        for (int i = 0; i < floorTiles.Length; i++)
        {
            floorTiles[i].transform.position = new Vector3(floorTiles[i].transform.position.x, gridOffset + getValidFloorHeight(i));
            ceilingTiles[i].transform.position = new Vector3(ceilingTiles[i].transform.position.x, gridOffset + getValidCeilingHeight(i));
        }
        //validate generation shape.  
    }

    private float getValidFloorHeight(int currentTile)
    {
        if(leftCell == null) //if this cell has no neighboring cell, then return default height- it probably is the starting cell where the monster originates.  
        {
            return 0f;
        }
        float minimumFloor = 0f;
        float maximumFloor = 0f;

        float leftCeilingHeight = 0;
        float leftFloorHeight = 0f;


        if (currentTile == 0) //this is the start of the new cell, we need to find the height of the final tile of the previous cell.  
        {
            leftCeilingHeight = this.leftCell.GetComponent<Cell>().ceilingTiles[9].transform.position.y;
            leftFloorHeight = this.leftCell.GetComponent<Cell>().floorTiles[9].transform.position.y;
        }
        else if (currentTile >= 1 && currentTile <= 9) //Find the tile to the left of this tile.  
        {
            leftCeilingHeight = ceilingTiles[currentTile - 1].transform.position.y;
            leftFloorHeight = floorTiles[currentTile - 1].transform.position.y;
        }
        else
        {
            print("Error");
        }
        
        maximumFloor = leftCeilingHeight - 10f;
        if(maximumFloor >= 20) { maximumFloor = 20; }


        int changeHeightRoll = Random.Range(1, 5);

        if (changeHeightRoll == 1)
        {
            //return a random integer casted to float from minimum to maximum
            int minStep = Mathf.CeilToInt(minimumFloor / 5f);
            int maxStep = Mathf.FloorToInt(maximumFloor / 5f);
            int randomStep = Random.Range(minStep, maxStep);
            return randomStep * 5f;
        }
        else
        {
            return leftFloorHeight - gridOffset;
        }
    }

    private float getValidCeilingHeight(int currentTile)
    {
        if (leftCell == null) //if this cell has no neighboring cell, then return default height- it probably is the starting cell where the monster originates.  
        {
            return 25f;
        }

        float minimumCeiling = 25f;
        float maximumCeiling = 25f;

        float floorHeight = floorTiles[currentTile].transform.position.y;
        float leftFloorHeight = 0f;

        if (currentTile == 0) //this is the start of the new cell, we need to find the height of the final tile of the previous cell.  
        {
            leftFloorHeight = this.leftCell.GetComponent<Cell>().floorTiles[9].transform.position.y;
        }
        else if (currentTile >= 1 && currentTile <= 9) //Find the tile to the left of this tile.  
        {
            leftFloorHeight = floorTiles[currentTile - 1].transform.position.y;
        }
        else
        {
            print("Error");
        }

        float option1 = leftFloorHeight + 10f;
        float option2 = floorHeight + 10f;

        minimumCeiling = Mathf.Max(option1, option2);

        //return a random integer casted to float from minimum to maximum
        int minStep = Mathf.CeilToInt(minimumCeiling / 5f);
        int maxStep = Mathf.FloorToInt(maximumCeiling / 5f);
        int randomStep = Random.Range(minStep, maxStep + 1);
        return randomStep * 5f;
    }

    private void generateTrapsAndEnemies()
    {
        for(int i = 0; i < floorTiles.Length; ++i)
        {
            
        }
        //choose traps randomly
    }

    public void initializeCell(GameObject left, GameObject right, float budget)
    {
        if(left != null)    { this.leftCell = left; }
        if (right != null)  { this.rightCell = right; }

        this.generationBudget = budget;

        //set the heights of all tiles, must be valid positions
        randomizeCellPositions();

        //generate traps in valid positions using budget.  
        generateTrapsAndEnemies();
    }

    //Update is called once per frame
    void Update()
    {
        
    }
}