using Unity.VisualScripting.Antlr3.Runtime.Tree;
using Unity.VisualScripting;
using UnityEngine;

public class Cell : MonoBehaviour
{
    [Header("Tiles")]
    [SerializeField] private GameObject[] floorTiles;
    [SerializeField] private GameObject[] ceilingTiles;

    private float generationBudget = 0f;
    public GameObject leftCell = null;
    public GameObject rightCell = null;

    public enum TrapType
    {
        LeftSpikes,
        RightSpikes,
        DownSpikes,
        UpSpikes,
        Lava,
        Turret,
        SwingingBall,
        SawbladeUp,
        SawbladeDown,
        SawbladeLeft,
        SawbladeRight,
        SawbladeUpLeft,
        SawbladeUpRight,
        SawbladeDownLeft,
        SawbladeDownRight
    }


    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        //since cells are generated by the game manager, we do not worry about the start method, and instead rely on the public initializeCell method to be called by the game manager.  
    }

    public void destroyCell()
    {
        if(rightCell != null) 
        {
            this.rightCell.gameObject.GetComponent<Cell>().leftCell = null; //set the left cell of the destroyed cell to null.  
        }
        GameObject.Destroy(this.gameObject);
    }

    private void randomizeCellPositions()
    {
        //Set the heights of all tiles.  
        //We should go left to right, floor to ceiling.  
        for(int i = 0; i < floorTiles.Length; i++)
        {
            break;
            //We then ensure that there is a valid gap between the tiles for the player to cross, of at least 5 units clearance
            //we check the height of the floor and ceiling tile to the left of the current iteration to verify the 5 unit clearance.  
            floorTiles[i].transform.position = new Vector3(this.transform.position.x, getValidFloorHeight(floorTiles[i]), this.transform.position.z);
            floorTiles[i].transform.position = new Vector3(this.transform.position.x, getValidCeilingHeight(ceilingTiles[i]), this.transform.position.z);
        }
        //validate generation shape.  
    }

    private int getValidFloorHeight(GameObject currentTile)
    {
        //Valid floor heights include any height where the floor does not raise such that the distance between the ceiling and floor is less than 5 units.  
        //Floor is checked first, ceiling next.  
        //This might make some outcomes more likely, may need further evaluation
        return 0;
    }

    private int getValidCeilingHeight(GameObject currentTile)
    {
        //Valid floor heights include any height where the floor does not raise such that the distance between the ceiling and floor is less than 5 units.  
        //Floor is checked first, ceiling next.  
        //This might make some outcomes more likely, may need further evaluation
        return 0;
    }

    private void generateTrapsAndEnemies()
    {
        for(int i = 0; i < floorTiles.Length; ++i)
        {
            
        }
        //choose traps randomly
    }

    public void initializeCell(GameObject left, GameObject right, float budget)
    {
        this.leftCell = left;
        this.rightCell = right;
        this.generationBudget = budget;

        //set the heights of all tiles, must be valid positions
        randomizeCellPositions();

        //generate traps in valid positions using budget.  
        generateTrapsAndEnemies();
    }

    

    

    // Update is called once per frame
    void Update()
    {
        
    }
}